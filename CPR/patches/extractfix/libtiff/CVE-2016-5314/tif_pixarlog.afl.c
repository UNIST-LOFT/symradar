/* $Id$ */

/*
 * Copyright (c) 1996-1997 Sam Leffler
 * Copyright (c) 1996 Pixar
 *
 * Permission to use, copy, modify, distribute, and sell this software and 
 * its documentation for any purpose is hereby granted without fee, provided
 * that (i) the above copyright notices and this permission notice appear in
 * all copies of the software and related documentation, and (ii) the names of
 * Pixar, Sam Leffler and Silicon Graphics may not be used in any advertising or
 * publicity relating to the software without the specific, prior written
 * permission of Pixar, Sam Leffler and Silicon Graphics.
 * 
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
 * 
 * IN NO EVENT SHALL PIXAR, SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
 * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
 * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
 * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
 * OF THIS SOFTWARE.
 */

#include "tiffiop.h"
#ifdef PIXARLOG_SUPPORT

/*
 * TIFF Library.
 * PixarLog Compression Support
 *
 * Contributed by Dan McCoy.
 *
 * PixarLog film support uses the TIFF library to store companded
 * 11 bit values into a tiff file, which are compressed using the 
 * zip compressor.  
 *
 * The codec can take as input and produce as output 32-bit IEEE float values 
 * as well as 16-bit or 8-bit unsigned integer values.
 *
 * On writing any of the above are converted into the internal
 * 11-bit log format.   In the case of  8 and 16 bit values, the
 * input is assumed to be unsigned linear color values that represent
 * the range 0-1.  In the case of IEEE values, the 0-1 range is assumed to
 * be the normal linear color range, in addition over 1 values are
 * accepted up to a value of about 25.0 to encode "hot" highlights and such.
 * The encoding is lossless for 8-bit values, slightly lossy for the
 * other bit depths.  The actual color precision should be better
 * than the human eye can perceive with extra room to allow for
 * error introduced by further image computation.  As with any quantized
 * color format, it is possible to perform image calculations which
 * expose the quantization error. This format should certainly be less 
 * susceptible to such errors than standard 8-bit encodings, but more
 * susceptible than straight 16-bit or 32-bit encodings.
 *
 * On reading the internal format is converted to the desired output format.
 * The program can request which format it desires by setting the internal
 * pseudo tag TIFFTAG_PIXARLOGDATAFMT to one of these possible values:
 *  PIXARLOGDATAFMT_FLOAT     = provide IEEE float values.
 *  PIXARLOGDATAFMT_16BIT     = provide unsigned 16-bit integer values
 *  PIXARLOGDATAFMT_8BIT      = provide unsigned 8-bit integer values
 *
 * alternately PIXARLOGDATAFMT_8BITABGR provides unsigned 8-bit integer
 * values with the difference that if there are exactly three or four channels
 * (rgb or rgba) it swaps the channel order (bgr or abgr).
 *
 * PIXARLOGDATAFMT_11BITLOG provides the internal encoding directly
 * packed in 16-bit values.   However no tools are supplied for interpreting
 * these values.
 *
 * "hot" (over 1.0) areas written in floating point get clamped to
 * 1.0 in the integer data types.
 *
 * When the file is closed after writing, the bit depth and sample format
 * are set always to appear as if 8-bit data has been written into it.
 * That way a naive program unaware of the particulars of the encoding
 * gets the format it is most likely able to handle.
 *
 * The codec does it's own horizontal differencing step on the coded
 * values so the libraries predictor stuff should be turned off.
 * The codec also handle byte swapping the encoded values as necessary
 * since the library does not have the information necessary
 * to know the bit depth of the raw unencoded buffer.
 *
 * NOTE: This decoder does not appear to update tif_rawcp, and tif_rawcc.
 * This can cause problems with the implementation of CHUNKY_STRIP_READ_SUPPORT
 * as noted in http://trac.osgeo.org/gdal/ticket/3894.   FrankW - Jan'11
 */

#include "tif_predict.h"
#include "zlib.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int uni_klee_patch_id;

void klee_select_patch(int *patch_id) {
  *patch_id = atoi(getenv("DAFL_PATCH_ID"));
}

void uni_klee_add_patch(int *patch_results, int patch_id, int result) {
  patch_results[patch_id] = result;
}

int uni_klee_choice(int *patch_results, int patch_id) {
//   FILE *fp=fopen(getenv("DAFL_RESULT_FILE"),"a");
//   if (fp == NULL) {
//     fprintf(stderr, "Error opening file!\n");
//     exit(1);
//   }
//   fprintf(fp, "%d ", patch_results[patch_id]);
//   fclose(fp);
  return patch_results[patch_id];
}

// UNI_KLEE_START
int __cpr_choice(char* lid, char* typestr,
                     long long* rvals, char** rvals_ids, int rvals_size,
                     int** lvals, char** lvals_ids, int lvals_size){
  // int patch_results[4096];
  int result;
  long long x = rvals[0];
  long long y = rvals[1];
  long long z = rvals[2];
  long long constant_a;
  int patch_results[390];
  // Patch buggy # 0
  result = (0);
  uni_klee_add_patch(patch_results, 0, result);
  // Patch 1-0 # 1
  result = (x == x);
  uni_klee_add_patch(patch_results, 1, result);
  // Patch 2-0 # 2
  constant_a = -10;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 2, result);
  // Patch 2-1 # 3
  constant_a = -9;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 3, result);
  // Patch 2-2 # 4
  constant_a = -8;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 4, result);
  // Patch 2-3 # 5
  constant_a = -7;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 5, result);
  // Patch 2-4 # 6
  constant_a = -6;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 6, result);
  // Patch 2-5 # 7
  constant_a = -5;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 7, result);
  // Patch 2-6 # 8
  constant_a = -4;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 8, result);
  // Patch 2-7 # 9
  constant_a = -3;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 9, result);
  // Patch 2-8 # 10
  constant_a = -2;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 10, result);
  // Patch 2-9 # 11
  constant_a = -1;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 11, result);
  // Patch 2-10 # 12
  constant_a = 0;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 12, result);
  // Patch 2-11 # 13
  constant_a = 1;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 13, result);
  // Patch 2-12 # 14
  constant_a = 2;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 14, result);
  // Patch 2-13 # 15
  constant_a = 3;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 15, result);
  // Patch 2-14 # 16
  constant_a = 4;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 16, result);
  // Patch 2-15 # 17
  constant_a = 5;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 17, result);
  // Patch 2-16 # 18
  constant_a = 6;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 18, result);
  // Patch 2-17 # 19
  constant_a = 7;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 19, result);
  // Patch 2-18 # 20
  constant_a = 8;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 20, result);
  // Patch 2-19 # 21
  constant_a = 9;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 21, result);
  // Patch 2-20 # 22
  constant_a = 10;
  result = (constant_a == x);
  uni_klee_add_patch(patch_results, 22, result);
  // Patch 3-0 # 23
  constant_a = -10;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 23, result);
  // Patch 3-1 # 24
  constant_a = -9;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 24, result);
  // Patch 3-2 # 25
  constant_a = -8;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 25, result);
  // Patch 3-3 # 26
  constant_a = -7;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 26, result);
  // Patch 3-4 # 27
  constant_a = -6;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 27, result);
  // Patch 3-5 # 28
  constant_a = -5;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 28, result);
  // Patch 3-6 # 29
  constant_a = -4;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 29, result);
  // Patch 3-7 # 30
  constant_a = -3;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 30, result);
  // Patch 3-8 # 31
  constant_a = -2;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 31, result);
  // Patch 3-9 # 32
  constant_a = -1;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 32, result);
  // Patch 3-10 # 33
  constant_a = 0;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 33, result);
  // Patch 3-11 # 34
  constant_a = 1;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 34, result);
  // Patch 3-12 # 35
  constant_a = 2;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 35, result);
  // Patch 3-13 # 36
  constant_a = 3;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 36, result);
  // Patch 3-14 # 37
  constant_a = 4;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 37, result);
  // Patch 3-15 # 38
  constant_a = 5;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 38, result);
  // Patch 3-16 # 39
  constant_a = 6;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 39, result);
  // Patch 3-17 # 40
  constant_a = 7;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 40, result);
  // Patch 3-18 # 41
  constant_a = 8;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 41, result);
  // Patch 3-19 # 42
  constant_a = 9;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 42, result);
  // Patch 3-20 # 43
  constant_a = 10;
  result = (constant_a == y);
  uni_klee_add_patch(patch_results, 43, result);
  // Patch 4-0 # 44
  constant_a = -10;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 44, result);
  // Patch 4-1 # 45
  constant_a = -9;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 45, result);
  // Patch 4-2 # 46
  constant_a = -8;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 46, result);
  // Patch 4-3 # 47
  constant_a = -7;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 47, result);
  // Patch 4-4 # 48
  constant_a = -6;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 48, result);
  // Patch 4-5 # 49
  constant_a = -5;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 49, result);
  // Patch 4-6 # 50
  constant_a = -4;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 50, result);
  // Patch 4-7 # 51
  constant_a = -3;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 51, result);
  // Patch 4-8 # 52
  constant_a = -2;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 52, result);
  // Patch 4-9 # 53
  constant_a = -1;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 53, result);
  // Patch 4-10 # 54
  constant_a = 0;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 54, result);
  // Patch 4-11 # 55
  constant_a = 1;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 55, result);
  // Patch 4-12 # 56
  constant_a = 2;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 56, result);
  // Patch 4-13 # 57
  constant_a = 3;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 57, result);
  // Patch 4-14 # 58
  constant_a = 4;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 58, result);
  // Patch 4-15 # 59
  constant_a = 5;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 59, result);
  // Patch 4-16 # 60
  constant_a = 6;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 60, result);
  // Patch 4-17 # 61
  constant_a = 7;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 61, result);
  // Patch 4-18 # 62
  constant_a = 8;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 62, result);
  // Patch 4-19 # 63
  constant_a = 9;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 63, result);
  // Patch 4-20 # 64
  constant_a = 10;
  result = (z == constant_a);
  uni_klee_add_patch(patch_results, 64, result);
  // Patch 5-0 # 65
  result = (y != x);
  uni_klee_add_patch(patch_results, 65, result);
  // Patch 6-0 # 66
  constant_a = -10;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 66, result);
  // Patch 6-1 # 67
  constant_a = -9;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 67, result);
  // Patch 6-2 # 68
  constant_a = -8;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 68, result);
  // Patch 6-3 # 69
  constant_a = -7;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 69, result);
  // Patch 6-4 # 70
  constant_a = -6;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 70, result);
  // Patch 6-5 # 71
  constant_a = -5;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 71, result);
  // Patch 6-6 # 72
  constant_a = -4;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 72, result);
  // Patch 6-7 # 73
  constant_a = -3;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 73, result);
  // Patch 6-8 # 74
  constant_a = -2;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 74, result);
  // Patch 6-9 # 75
  constant_a = -1;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 75, result);
  // Patch 6-10 # 76
  constant_a = 0;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 76, result);
  // Patch 6-11 # 77
  constant_a = 1;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 77, result);
  // Patch 6-12 # 78
  constant_a = 2;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 78, result);
  // Patch 6-13 # 79
  constant_a = 3;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 79, result);
  // Patch 6-14 # 80
  constant_a = 4;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 80, result);
  // Patch 6-15 # 81
  constant_a = 5;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 81, result);
  // Patch 6-16 # 82
  constant_a = 6;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 82, result);
  // Patch 6-17 # 83
  constant_a = 7;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 83, result);
  // Patch 6-18 # 84
  constant_a = 8;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 84, result);
  // Patch 6-19 # 85
  constant_a = 9;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 85, result);
  // Patch 6-20 # 86
  constant_a = 10;
  result = (constant_a != x);
  uni_klee_add_patch(patch_results, 86, result);
  // Patch 7-0 # 87
  result = (z != x);
  uni_klee_add_patch(patch_results, 87, result);
  // Patch 8-0 # 88
  constant_a = -10;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 88, result);
  // Patch 8-1 # 89
  constant_a = -9;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 89, result);
  // Patch 8-2 # 90
  constant_a = -8;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 90, result);
  // Patch 8-3 # 91
  constant_a = -7;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 91, result);
  // Patch 8-4 # 92
  constant_a = -6;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 92, result);
  // Patch 8-5 # 93
  constant_a = -5;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 93, result);
  // Patch 8-6 # 94
  constant_a = -4;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 94, result);
  // Patch 8-7 # 95
  constant_a = -3;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 95, result);
  // Patch 8-8 # 96
  constant_a = -2;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 96, result);
  // Patch 8-9 # 97
  constant_a = -1;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 97, result);
  // Patch 8-10 # 98
  constant_a = 0;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 98, result);
  // Patch 8-11 # 99
  constant_a = 1;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 99, result);
  // Patch 8-12 # 100
  constant_a = 2;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 100, result);
  // Patch 8-13 # 101
  constant_a = 3;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 101, result);
  // Patch 8-14 # 102
  constant_a = 4;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 102, result);
  // Patch 8-15 # 103
  constant_a = 5;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 103, result);
  // Patch 8-16 # 104
  constant_a = 6;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 104, result);
  // Patch 8-17 # 105
  constant_a = 7;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 105, result);
  // Patch 8-18 # 106
  constant_a = 8;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 106, result);
  // Patch 8-19 # 107
  constant_a = 9;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 107, result);
  // Patch 8-20 # 108
  constant_a = 10;
  result = (constant_a != y);
  uni_klee_add_patch(patch_results, 108, result);
  // Patch 9-0 # 109
  result = (z != y);
  uni_klee_add_patch(patch_results, 109, result);
  // Patch 10-0 # 110
  constant_a = -10;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 110, result);
  // Patch 10-1 # 111
  constant_a = -9;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 111, result);
  // Patch 10-2 # 112
  constant_a = -8;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 112, result);
  // Patch 10-3 # 113
  constant_a = -7;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 113, result);
  // Patch 10-4 # 114
  constant_a = -6;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 114, result);
  // Patch 10-5 # 115
  constant_a = -5;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 115, result);
  // Patch 10-6 # 116
  constant_a = -4;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 116, result);
  // Patch 10-7 # 117
  constant_a = -3;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 117, result);
  // Patch 10-8 # 118
  constant_a = -2;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 118, result);
  // Patch 10-9 # 119
  constant_a = -1;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 119, result);
  // Patch 10-10 # 120
  constant_a = 0;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 120, result);
  // Patch 10-11 # 121
  constant_a = 1;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 121, result);
  // Patch 10-12 # 122
  constant_a = 2;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 122, result);
  // Patch 10-13 # 123
  constant_a = 3;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 123, result);
  // Patch 10-14 # 124
  constant_a = 4;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 124, result);
  // Patch 10-15 # 125
  constant_a = 5;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 125, result);
  // Patch 10-16 # 126
  constant_a = 6;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 126, result);
  // Patch 10-17 # 127
  constant_a = 7;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 127, result);
  // Patch 10-18 # 128
  constant_a = 8;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 128, result);
  // Patch 10-19 # 129
  constant_a = 9;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 129, result);
  // Patch 10-20 # 130
  constant_a = 10;
  result = (z != constant_a);
  uni_klee_add_patch(patch_results, 130, result);
  // Patch 11-0 # 131
  constant_a = -10;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 131, result);
  // Patch 11-1 # 132
  constant_a = -9;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 132, result);
  // Patch 11-2 # 133
  constant_a = -8;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 133, result);
  // Patch 11-3 # 134
  constant_a = -7;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 134, result);
  // Patch 11-4 # 135
  constant_a = -6;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 135, result);
  // Patch 11-5 # 136
  constant_a = -5;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 136, result);
  // Patch 11-6 # 137
  constant_a = -4;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 137, result);
  // Patch 11-7 # 138
  constant_a = -3;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 138, result);
  // Patch 11-8 # 139
  constant_a = -2;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 139, result);
  // Patch 11-9 # 140
  constant_a = -1;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 140, result);
  // Patch 11-10 # 141
  constant_a = 0;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 141, result);
  // Patch 11-11 # 142
  constant_a = 1;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 142, result);
  // Patch 11-12 # 143
  constant_a = 2;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 143, result);
  // Patch 11-13 # 144
  constant_a = 3;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 144, result);
  // Patch 11-14 # 145
  constant_a = 4;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 145, result);
  // Patch 11-15 # 146
  constant_a = 5;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 146, result);
  // Patch 11-16 # 147
  constant_a = 6;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 147, result);
  // Patch 11-17 # 148
  constant_a = 7;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 148, result);
  // Patch 11-18 # 149
  constant_a = 8;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 149, result);
  // Patch 11-19 # 150
  constant_a = 9;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 150, result);
  // Patch 11-20 # 151
  constant_a = 10;
  result = (constant_a < x);
  uni_klee_add_patch(patch_results, 151, result);
  // Patch 12-0 # 152
  result = (x < y);
  uni_klee_add_patch(patch_results, 152, result);
  // Patch 13-0 # 153
  constant_a = -10;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 153, result);
  // Patch 13-1 # 154
  constant_a = -9;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 154, result);
  // Patch 13-2 # 155
  constant_a = -8;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 155, result);
  // Patch 13-3 # 156
  constant_a = -7;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 156, result);
  // Patch 13-4 # 157
  constant_a = -6;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 157, result);
  // Patch 13-5 # 158
  constant_a = -5;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 158, result);
  // Patch 13-6 # 159
  constant_a = -4;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 159, result);
  // Patch 13-7 # 160
  constant_a = -3;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 160, result);
  // Patch 13-8 # 161
  constant_a = -2;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 161, result);
  // Patch 13-9 # 162
  constant_a = -1;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 162, result);
  // Patch 13-10 # 163
  constant_a = 0;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 163, result);
  // Patch 13-11 # 164
  constant_a = 1;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 164, result);
  // Patch 13-12 # 165
  constant_a = 2;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 165, result);
  // Patch 13-13 # 166
  constant_a = 3;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 166, result);
  // Patch 13-14 # 167
  constant_a = 4;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 167, result);
  // Patch 13-15 # 168
  constant_a = 5;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 168, result);
  // Patch 13-16 # 169
  constant_a = 6;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 169, result);
  // Patch 13-17 # 170
  constant_a = 7;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 170, result);
  // Patch 13-18 # 171
  constant_a = 8;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 171, result);
  // Patch 13-19 # 172
  constant_a = 9;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 172, result);
  // Patch 13-20 # 173
  constant_a = 10;
  result = (constant_a < y);
  uni_klee_add_patch(patch_results, 173, result);
  // Patch 14-0 # 174
  result = (z < y);
  uni_klee_add_patch(patch_results, 174, result);
  // Patch 15-0 # 175
  constant_a = -10;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 175, result);
  // Patch 15-1 # 176
  constant_a = -9;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 176, result);
  // Patch 15-2 # 177
  constant_a = -8;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 177, result);
  // Patch 15-3 # 178
  constant_a = -7;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 178, result);
  // Patch 15-4 # 179
  constant_a = -6;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 179, result);
  // Patch 15-5 # 180
  constant_a = -5;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 180, result);
  // Patch 15-6 # 181
  constant_a = -4;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 181, result);
  // Patch 15-7 # 182
  constant_a = -3;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 182, result);
  // Patch 15-8 # 183
  constant_a = -2;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 183, result);
  // Patch 15-9 # 184
  constant_a = -1;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 184, result);
  // Patch 15-10 # 185
  constant_a = 0;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 185, result);
  // Patch 15-11 # 186
  constant_a = 1;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 186, result);
  // Patch 15-12 # 187
  constant_a = 2;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 187, result);
  // Patch 15-13 # 188
  constant_a = 3;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 188, result);
  // Patch 15-14 # 189
  constant_a = 4;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 189, result);
  // Patch 15-15 # 190
  constant_a = 5;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 190, result);
  // Patch 15-16 # 191
  constant_a = 6;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 191, result);
  // Patch 15-17 # 192
  constant_a = 7;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 192, result);
  // Patch 15-18 # 193
  constant_a = 8;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 193, result);
  // Patch 15-19 # 194
  constant_a = 9;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 194, result);
  // Patch 15-20 # 195
  constant_a = 10;
  result = (x < constant_a);
  uni_klee_add_patch(patch_results, 195, result);
  // Patch 16-0 # 196
  constant_a = -10;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 196, result);
  // Patch 16-1 # 197
  constant_a = -9;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 197, result);
  // Patch 16-2 # 198
  constant_a = -8;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 198, result);
  // Patch 16-3 # 199
  constant_a = -7;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 199, result);
  // Patch 16-4 # 200
  constant_a = -6;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 200, result);
  // Patch 16-5 # 201
  constant_a = -5;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 201, result);
  // Patch 16-6 # 202
  constant_a = -4;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 202, result);
  // Patch 16-7 # 203
  constant_a = -3;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 203, result);
  // Patch 16-8 # 204
  constant_a = -2;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 204, result);
  // Patch 16-9 # 205
  constant_a = -1;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 205, result);
  // Patch 16-10 # 206
  constant_a = 0;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 206, result);
  // Patch 16-11 # 207
  constant_a = 1;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 207, result);
  // Patch 16-12 # 208
  constant_a = 2;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 208, result);
  // Patch 16-13 # 209
  constant_a = 3;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 209, result);
  // Patch 16-14 # 210
  constant_a = 4;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 210, result);
  // Patch 16-15 # 211
  constant_a = 5;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 211, result);
  // Patch 16-16 # 212
  constant_a = 6;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 212, result);
  // Patch 16-17 # 213
  constant_a = 7;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 213, result);
  // Patch 16-18 # 214
  constant_a = 8;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 214, result);
  // Patch 16-19 # 215
  constant_a = 9;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 215, result);
  // Patch 16-20 # 216
  constant_a = 10;
  result = (y < constant_a);
  uni_klee_add_patch(patch_results, 216, result);
  // Patch 17-0 # 217
  constant_a = -10;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 217, result);
  // Patch 17-1 # 218
  constant_a = -9;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 218, result);
  // Patch 17-2 # 219
  constant_a = -8;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 219, result);
  // Patch 17-3 # 220
  constant_a = -7;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 220, result);
  // Patch 17-4 # 221
  constant_a = -6;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 221, result);
  // Patch 17-5 # 222
  constant_a = -5;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 222, result);
  // Patch 17-6 # 223
  constant_a = -4;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 223, result);
  // Patch 17-7 # 224
  constant_a = -3;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 224, result);
  // Patch 17-8 # 225
  constant_a = -2;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 225, result);
  // Patch 17-9 # 226
  constant_a = -1;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 226, result);
  // Patch 17-10 # 227
  constant_a = 0;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 227, result);
  // Patch 17-11 # 228
  constant_a = 1;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 228, result);
  // Patch 17-12 # 229
  constant_a = 2;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 229, result);
  // Patch 17-13 # 230
  constant_a = 3;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 230, result);
  // Patch 17-14 # 231
  constant_a = 4;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 231, result);
  // Patch 17-15 # 232
  constant_a = 5;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 232, result);
  // Patch 17-16 # 233
  constant_a = 6;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 233, result);
  // Patch 17-17 # 234
  constant_a = 7;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 234, result);
  // Patch 17-18 # 235
  constant_a = 8;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 235, result);
  // Patch 17-19 # 236
  constant_a = 9;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 236, result);
  // Patch 17-20 # 237
  constant_a = 10;
  result = (z < constant_a);
  uni_klee_add_patch(patch_results, 237, result);
  // Patch 18-0 # 238
  result = (x < z);
  uni_klee_add_patch(patch_results, 238, result);
  // Patch 19-0 # 239
  constant_a = -10;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 239, result);
  // Patch 19-1 # 240
  constant_a = -9;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 240, result);
  // Patch 19-2 # 241
  constant_a = -8;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 241, result);
  // Patch 19-3 # 242
  constant_a = -7;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 242, result);
  // Patch 19-4 # 243
  constant_a = -6;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 243, result);
  // Patch 19-5 # 244
  constant_a = -5;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 244, result);
  // Patch 19-6 # 245
  constant_a = -4;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 245, result);
  // Patch 19-7 # 246
  constant_a = -3;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 246, result);
  // Patch 19-8 # 247
  constant_a = -2;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 247, result);
  // Patch 19-9 # 248
  constant_a = -1;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 248, result);
  // Patch 19-10 # 249
  constant_a = 0;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 249, result);
  // Patch 19-11 # 250
  constant_a = 1;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 250, result);
  // Patch 19-12 # 251
  constant_a = 2;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 251, result);
  // Patch 19-13 # 252
  constant_a = 3;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 252, result);
  // Patch 19-14 # 253
  constant_a = 4;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 253, result);
  // Patch 19-15 # 254
  constant_a = 5;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 254, result);
  // Patch 19-16 # 255
  constant_a = 6;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 255, result);
  // Patch 19-17 # 256
  constant_a = 7;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 256, result);
  // Patch 19-18 # 257
  constant_a = 8;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 257, result);
  // Patch 19-19 # 258
  constant_a = 9;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 258, result);
  // Patch 19-20 # 259
  constant_a = 10;
  result = (constant_a < z);
  uni_klee_add_patch(patch_results, 259, result);
  // Patch 20-0 # 260
  constant_a = -10;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 260, result);
  // Patch 20-1 # 261
  constant_a = -9;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 261, result);
  // Patch 20-2 # 262
  constant_a = -8;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 262, result);
  // Patch 20-3 # 263
  constant_a = -7;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 263, result);
  // Patch 20-4 # 264
  constant_a = -6;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 264, result);
  // Patch 20-5 # 265
  constant_a = -5;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 265, result);
  // Patch 20-6 # 266
  constant_a = -4;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 266, result);
  // Patch 20-7 # 267
  constant_a = -3;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 267, result);
  // Patch 20-8 # 268
  constant_a = -2;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 268, result);
  // Patch 20-9 # 269
  constant_a = -1;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 269, result);
  // Patch 20-10 # 270
  constant_a = 0;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 270, result);
  // Patch 20-11 # 271
  constant_a = 1;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 271, result);
  // Patch 20-12 # 272
  constant_a = 2;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 272, result);
  // Patch 20-13 # 273
  constant_a = 3;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 273, result);
  // Patch 20-14 # 274
  constant_a = 4;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 274, result);
  // Patch 20-15 # 275
  constant_a = 5;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 275, result);
  // Patch 20-16 # 276
  constant_a = 6;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 276, result);
  // Patch 20-17 # 277
  constant_a = 7;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 277, result);
  // Patch 20-18 # 278
  constant_a = 8;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 278, result);
  // Patch 20-19 # 279
  constant_a = 9;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 279, result);
  // Patch 20-20 # 280
  constant_a = 10;
  result = (constant_a <= x);
  uni_klee_add_patch(patch_results, 280, result);
  // Patch 21-0 # 281
  result = (x <= y);
  uni_klee_add_patch(patch_results, 281, result);
  // Patch 22-0 # 282
  constant_a = -10;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 282, result);
  // Patch 22-1 # 283
  constant_a = -9;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 283, result);
  // Patch 22-2 # 284
  constant_a = -8;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 284, result);
  // Patch 22-3 # 285
  constant_a = -7;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 285, result);
  // Patch 22-4 # 286
  constant_a = -6;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 286, result);
  // Patch 22-5 # 287
  constant_a = -5;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 287, result);
  // Patch 22-6 # 288
  constant_a = -4;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 288, result);
  // Patch 22-7 # 289
  constant_a = -3;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 289, result);
  // Patch 22-8 # 290
  constant_a = -2;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 290, result);
  // Patch 22-9 # 291
  constant_a = -1;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 291, result);
  // Patch 22-10 # 292
  constant_a = 0;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 292, result);
  // Patch 22-11 # 293
  constant_a = 1;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 293, result);
  // Patch 22-12 # 294
  constant_a = 2;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 294, result);
  // Patch 22-13 # 295
  constant_a = 3;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 295, result);
  // Patch 22-14 # 296
  constant_a = 4;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 296, result);
  // Patch 22-15 # 297
  constant_a = 5;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 297, result);
  // Patch 22-16 # 298
  constant_a = 6;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 298, result);
  // Patch 22-17 # 299
  constant_a = 7;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 299, result);
  // Patch 22-18 # 300
  constant_a = 8;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 300, result);
  // Patch 22-19 # 301
  constant_a = 9;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 301, result);
  // Patch 22-20 # 302
  constant_a = 10;
  result = (constant_a <= y);
  uni_klee_add_patch(patch_results, 302, result);
  // Patch 23-0 # 303
  result = (z <= y);
  uni_klee_add_patch(patch_results, 303, result);
  // Patch 24-0 # 304
  constant_a = -10;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 304, result);
  // Patch 24-1 # 305
  constant_a = -9;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 305, result);
  // Patch 24-2 # 306
  constant_a = -8;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 306, result);
  // Patch 24-3 # 307
  constant_a = -7;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 307, result);
  // Patch 24-4 # 308
  constant_a = -6;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 308, result);
  // Patch 24-5 # 309
  constant_a = -5;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 309, result);
  // Patch 24-6 # 310
  constant_a = -4;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 310, result);
  // Patch 24-7 # 311
  constant_a = -3;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 311, result);
  // Patch 24-8 # 312
  constant_a = -2;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 312, result);
  // Patch 24-9 # 313
  constant_a = -1;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 313, result);
  // Patch 24-10 # 314
  constant_a = 0;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 314, result);
  // Patch 24-11 # 315
  constant_a = 1;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 315, result);
  // Patch 24-12 # 316
  constant_a = 2;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 316, result);
  // Patch 24-13 # 317
  constant_a = 3;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 317, result);
  // Patch 24-14 # 318
  constant_a = 4;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 318, result);
  // Patch 24-15 # 319
  constant_a = 5;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 319, result);
  // Patch 24-16 # 320
  constant_a = 6;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 320, result);
  // Patch 24-17 # 321
  constant_a = 7;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 321, result);
  // Patch 24-18 # 322
  constant_a = 8;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 322, result);
  // Patch 24-19 # 323
  constant_a = 9;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 323, result);
  // Patch 24-20 # 324
  constant_a = 10;
  result = (x <= constant_a);
  uni_klee_add_patch(patch_results, 324, result);
  // Patch 25-0 # 325
  constant_a = -10;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 325, result);
  // Patch 25-1 # 326
  constant_a = -9;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 326, result);
  // Patch 25-2 # 327
  constant_a = -8;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 327, result);
  // Patch 25-3 # 328
  constant_a = -7;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 328, result);
  // Patch 25-4 # 329
  constant_a = -6;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 329, result);
  // Patch 25-5 # 330
  constant_a = -5;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 330, result);
  // Patch 25-6 # 331
  constant_a = -4;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 331, result);
  // Patch 25-7 # 332
  constant_a = -3;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 332, result);
  // Patch 25-8 # 333
  constant_a = -2;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 333, result);
  // Patch 25-9 # 334
  constant_a = -1;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 334, result);
  // Patch 25-10 # 335
  constant_a = 0;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 335, result);
  // Patch 25-11 # 336
  constant_a = 1;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 336, result);
  // Patch 25-12 # 337
  constant_a = 2;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 337, result);
  // Patch 25-13 # 338
  constant_a = 3;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 338, result);
  // Patch 25-14 # 339
  constant_a = 4;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 339, result);
  // Patch 25-15 # 340
  constant_a = 5;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 340, result);
  // Patch 25-16 # 341
  constant_a = 6;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 341, result);
  // Patch 25-17 # 342
  constant_a = 7;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 342, result);
  // Patch 25-18 # 343
  constant_a = 8;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 343, result);
  // Patch 25-19 # 344
  constant_a = 9;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 344, result);
  // Patch 25-20 # 345
  constant_a = 10;
  result = (y <= constant_a);
  uni_klee_add_patch(patch_results, 345, result);
  // Patch 26-0 # 346
  constant_a = -10;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 346, result);
  // Patch 26-1 # 347
  constant_a = -9;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 347, result);
  // Patch 26-2 # 348
  constant_a = -8;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 348, result);
  // Patch 26-3 # 349
  constant_a = -7;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 349, result);
  // Patch 26-4 # 350
  constant_a = -6;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 350, result);
  // Patch 26-5 # 351
  constant_a = -5;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 351, result);
  // Patch 26-6 # 352
  constant_a = -4;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 352, result);
  // Patch 26-7 # 353
  constant_a = -3;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 353, result);
  // Patch 26-8 # 354
  constant_a = -2;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 354, result);
  // Patch 26-9 # 355
  constant_a = -1;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 355, result);
  // Patch 26-10 # 356
  constant_a = 0;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 356, result);
  // Patch 26-11 # 357
  constant_a = 1;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 357, result);
  // Patch 26-12 # 358
  constant_a = 2;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 358, result);
  // Patch 26-13 # 359
  constant_a = 3;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 359, result);
  // Patch 26-14 # 360
  constant_a = 4;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 360, result);
  // Patch 26-15 # 361
  constant_a = 5;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 361, result);
  // Patch 26-16 # 362
  constant_a = 6;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 362, result);
  // Patch 26-17 # 363
  constant_a = 7;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 363, result);
  // Patch 26-18 # 364
  constant_a = 8;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 364, result);
  // Patch 26-19 # 365
  constant_a = 9;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 365, result);
  // Patch 26-20 # 366
  constant_a = 10;
  result = (z <= constant_a);
  uni_klee_add_patch(patch_results, 366, result);
  // Patch 27-0 # 367
  result = (x <= z);
  uni_klee_add_patch(patch_results, 367, result);
  // Patch 28-0 # 368
  constant_a = -10;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 368, result);
  // Patch 28-1 # 369
  constant_a = -9;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 369, result);
  // Patch 28-2 # 370
  constant_a = -8;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 370, result);
  // Patch 28-3 # 371
  constant_a = -7;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 371, result);
  // Patch 28-4 # 372
  constant_a = -6;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 372, result);
  // Patch 28-5 # 373
  constant_a = -5;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 373, result);
  // Patch 28-6 # 374
  constant_a = -4;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 374, result);
  // Patch 28-7 # 375
  constant_a = -3;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 375, result);
  // Patch 28-8 # 376
  constant_a = -2;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 376, result);
  // Patch 28-9 # 377
  constant_a = -1;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 377, result);
  // Patch 28-10 # 378
  constant_a = 0;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 378, result);
  // Patch 28-11 # 379
  constant_a = 1;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 379, result);
  // Patch 28-12 # 380
  constant_a = 2;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 380, result);
  // Patch 28-13 # 381
  constant_a = 3;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 381, result);
  // Patch 28-14 # 382
  constant_a = 4;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 382, result);
  // Patch 28-15 # 383
  constant_a = 5;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 383, result);
  // Patch 28-16 # 384
  constant_a = 6;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 384, result);
  // Patch 28-17 # 385
  constant_a = 7;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 385, result);
  // Patch 28-18 # 386
  constant_a = 8;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 386, result);
  // Patch 28-19 # 387
  constant_a = 9;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 387, result);
  // Patch 28-20 # 388
  constant_a = 10;
  result = (constant_a <= z);
  uni_klee_add_patch(patch_results, 388, result);
  // Patch correct # 389
  result = (y > x);
  uni_klee_add_patch(patch_results, 389, result);
  klee_select_patch(&uni_klee_patch_id);
  return uni_klee_choice(patch_results, uni_klee_patch_id);
}
// UNI_KLEE_END


/* Tables for converting to/from 11 bit coded values */

#define  TSIZE	 2048		/* decode table size (11-bit tokens) */
#define  TSIZEP1 2049		/* Plus one for slop */
#define  ONE	 1250		/* token value of 1.0 exactly */
#define  RATIO	 1.004		/* nominal ratio for log part */

#define CODE_MASK 0x7ff         /* 11 bits. */

static float  Fltsize;
static float  LogK1, LogK2;

#define REPEAT(n, op)   { int i; i=n; do { i--; op; } while (i>0); }

static void
horizontalAccumulateF(uint16 *wp, int n, int stride, float *op,
	float *ToLinearF)
{
    register unsigned int  cr, cg, cb, ca, mask;
    register float  t0, t1, t2, t3;

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    t0 = ToLinearF[cr = (wp[0] & mask)];
	    t1 = ToLinearF[cg = (wp[1] & mask)];
	    t2 = ToLinearF[cb = (wp[2] & mask)];
	    op[0] = t0;
	    op[1] = t1;
	    op[2] = t2;
	    n -= 3;
	    while (n > 0) {
		wp += 3;
		op += 3;
		n -= 3;
		t0 = ToLinearF[(cr += wp[0]) & mask];
		t1 = ToLinearF[(cg += wp[1]) & mask];
		t2 = ToLinearF[(cb += wp[2]) & mask];
		op[0] = t0;
		op[1] = t1;
		op[2] = t2;
	    }
	} else if (stride == 4) {
	    t0 = ToLinearF[cr = (wp[0] & mask)];
	    t1 = ToLinearF[cg = (wp[1] & mask)];
	    t2 = ToLinearF[cb = (wp[2] & mask)];
	    t3 = ToLinearF[ca = (wp[3] & mask)];
	    op[0] = t0;
	    op[1] = t1;
	    op[2] = t2;
	    op[3] = t3;
	    n -= 4;
	    while (n > 0) {
		wp += 4;
		op += 4;
		n -= 4;
		t0 = ToLinearF[(cr += wp[0]) & mask];
		t1 = ToLinearF[(cg += wp[1]) & mask];
		t2 = ToLinearF[(cb += wp[2]) & mask];
		t3 = ToLinearF[(ca += wp[3]) & mask];
		op[0] = t0;
		op[1] = t1;
		op[2] = t2;
		op[3] = t3;
	    }
	} else {
	    REPEAT(stride, *op = ToLinearF[*wp&mask]; wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++)
		n -= stride;
	    }
	}
    }
}

static void
horizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,
	float *ToLinearF)
{
    register unsigned int  cr, cg, cb, ca, mask;
    register float  t0, t1, t2, t3;

#define SCALE12 2048.0F
#define CLAMP12(t) (((t) < 3071) ? (uint16) (t) : 3071)

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;
	    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;
	    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;
	    op[0] = CLAMP12(t0);
	    op[1] = CLAMP12(t1);
	    op[2] = CLAMP12(t2);
	    n -= 3;
	    while (n > 0) {
		wp += 3;
		op += 3;
		n -= 3;
		t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;
		t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;
		t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;
		op[0] = CLAMP12(t0);
		op[1] = CLAMP12(t1);
		op[2] = CLAMP12(t2);
	    }
	} else if (stride == 4) {
	    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;
	    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;
	    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;
	    t3 = ToLinearF[ca = (wp[3] & mask)] * SCALE12;
	    op[0] = CLAMP12(t0);
	    op[1] = CLAMP12(t1);
	    op[2] = CLAMP12(t2);
	    op[3] = CLAMP12(t3);
	    n -= 4;
	    while (n > 0) {
		wp += 4;
		op += 4;
		n -= 4;
		t0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;
		t1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;
		t2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;
		t3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12;
		op[0] = CLAMP12(t0);
		op[1] = CLAMP12(t1);
		op[2] = CLAMP12(t2);
		op[3] = CLAMP12(t3);
	    }
	} else {
	    REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;
                           *op = CLAMP12(t0); wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12;
		    *op = CLAMP12(t0);  wp++; op++)
		n -= stride;
	    }
	}
    }
}

static void
horizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,
	uint16 *ToLinear16)
{
    register unsigned int  cr, cg, cb, ca, mask;

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    op[0] = ToLinear16[cr = (wp[0] & mask)];
	    op[1] = ToLinear16[cg = (wp[1] & mask)];
	    op[2] = ToLinear16[cb = (wp[2] & mask)];
	    n -= 3;
	    while (n > 0) {
		wp += 3;
		op += 3;
		n -= 3;
		op[0] = ToLinear16[(cr += wp[0]) & mask];
		op[1] = ToLinear16[(cg += wp[1]) & mask];
		op[2] = ToLinear16[(cb += wp[2]) & mask];
	    }
	} else if (stride == 4) {
	    op[0] = ToLinear16[cr = (wp[0] & mask)];
	    op[1] = ToLinear16[cg = (wp[1] & mask)];
	    op[2] = ToLinear16[cb = (wp[2] & mask)];
	    op[3] = ToLinear16[ca = (wp[3] & mask)];
	    n -= 4;
	    while (n > 0) {
		wp += 4;
		op += 4;
		n -= 4;
		op[0] = ToLinear16[(cr += wp[0]) & mask];
		op[1] = ToLinear16[(cg += wp[1]) & mask];
		op[2] = ToLinear16[(cb += wp[2]) & mask];
		op[3] = ToLinear16[(ca += wp[3]) & mask];
	    }
	} else {
	    REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++)
		n -= stride;
	    }
	}
    }
}

/* 
 * Returns the log encoded 11-bit values with the horizontal
 * differencing undone.
 */
static void
horizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)
{
    register unsigned int cr, cg, cb, ca, mask;

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    op[0] = wp[0];  op[1] = wp[1];  op[2] = wp[2];
            cr = wp[0];  cg = wp[1];  cb = wp[2];
	    n -= 3;
	    while (n > 0) {
		wp += 3;
		op += 3;
		n -= 3;
		op[0] = (uint16)((cr += wp[0]) & mask);
		op[1] = (uint16)((cg += wp[1]) & mask);
		op[2] = (uint16)((cb += wp[2]) & mask);
	    }
	} else if (stride == 4) {
	    op[0] = wp[0];  op[1] = wp[1];
	    op[2] = wp[2];  op[3] = wp[3];
            cr = wp[0]; cg = wp[1]; cb = wp[2]; ca = wp[3];
	    n -= 4;
	    while (n > 0) {
		wp += 4;
		op += 4;
		n -= 4;
		op[0] = (uint16)((cr += wp[0]) & mask);
		op[1] = (uint16)((cg += wp[1]) & mask);
		op[2] = (uint16)((cb += wp[2]) & mask);
		op[3] = (uint16)((ca += wp[3]) & mask);
	    } 
	} else {
	    REPEAT(stride, *op = *wp&mask; wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; *op = *wp&mask; wp++; op++)
		n -= stride;
	    }
	}
    }
}

static void
horizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,
	unsigned char *ToLinear8)
{
    register unsigned int  cr, cg, cb, ca, mask;

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    op[0] = ToLinear8[cr = (wp[0] & mask)];
	    op[1] = ToLinear8[cg = (wp[1] & mask)];
	    op[2] = ToLinear8[cb = (wp[2] & mask)];
	    n -= 3;
	    while (n > 0) {
		n -= 3;
		wp += 3;
		op += 3;
		op[0] = ToLinear8[(cr += wp[0]) & mask];
		op[1] = ToLinear8[(cg += wp[1]) & mask];
		op[2] = ToLinear8[(cb += wp[2]) & mask];
	    }
	} else if (stride == 4) {
	    op[0] = ToLinear8[cr = (wp[0] & mask)];
	    op[1] = ToLinear8[cg = (wp[1] & mask)];
	    op[2] = ToLinear8[cb = (wp[2] & mask)];
	    op[3] = ToLinear8[ca = (wp[3] & mask)];
	    n -= 4;
	    while (n > 0) {
		n -= 4;
		wp += 4;
		op += 4;
		op[0] = ToLinear8[(cr += wp[0]) & mask];
		op[1] = ToLinear8[(cg += wp[1]) & mask];
		op[2] = ToLinear8[(cb += wp[2]) & mask];
		op[3] = ToLinear8[(ca += wp[3]) & mask];
	    }
	} else {
	    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)
		n -= stride;
	    }
	}
    }
}


static void
horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,
	unsigned char *ToLinear8)
{
    register unsigned int  cr, cg, cb, ca, mask;
    register unsigned char  t0, t1, t2, t3;

    if (n >= stride) {
	mask = CODE_MASK;
	if (stride == 3) {
	    op[0] = 0;
	    t1 = ToLinear8[cb = (wp[2] & mask)];
	    t2 = ToLinear8[cg = (wp[1] & mask)];
	    t3 = ToLinear8[cr = (wp[0] & mask)];
	    op[1] = t1;
	    op[2] = t2;
	    op[3] = t3;
	    n -= 3;
	    while (n > 0) {
		n -= 3;
		wp += 3;
		op += 4;
		op[0] = 0;
		t1 = ToLinear8[(cb += wp[2]) & mask];
		t2 = ToLinear8[(cg += wp[1]) & mask];
		t3 = ToLinear8[(cr += wp[0]) & mask];
		op[1] = t1;
		op[2] = t2;
		op[3] = t3;
	    }
	} else if (stride == 4) {
	    t0 = ToLinear8[ca = (wp[3] & mask)];
	    t1 = ToLinear8[cb = (wp[2] & mask)];
	    t2 = ToLinear8[cg = (wp[1] & mask)];
	    t3 = ToLinear8[cr = (wp[0] & mask)];
	    op[0] = t0;
	    op[1] = t1;
	    op[2] = t2;
	    op[3] = t3;
	    n -= 4;
	    while (n > 0) {
		n -= 4;
		wp += 4;
		op += 4;
		t0 = ToLinear8[(ca += wp[3]) & mask];
		t1 = ToLinear8[(cb += wp[2]) & mask];
		t2 = ToLinear8[(cg += wp[1]) & mask];
		t3 = ToLinear8[(cr += wp[0]) & mask];
		op[0] = t0;
		op[1] = t1;
		op[2] = t2;
		op[3] = t3;
	    }
	} else {
	    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride,
		    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)
		n -= stride;
	    }
	}
    }
}

/*
 * State block for each open TIFF
 * file using PixarLog compression/decompression.
 */
typedef	struct {
	TIFFPredictorState	predict;
tmsize_t  tbuf_size;

	z_stream		stream;
	uint16			*tbuf; 
	uint16			stride;
	int			state;
	int			user_datafmt;
	int			quality;
#define PLSTATE_INIT 1

	TIFFVSetMethod		vgetparent;	/* super-class method */
	TIFFVSetMethod		vsetparent;	/* super-class method */

	float *ToLinearF;
	uint16 *ToLinear16;
	unsigned char *ToLinear8;
	uint16  *FromLT2;
	uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
	uint16  *From8;
	
} PixarLogState;

static int
PixarLogMakeTables(PixarLogState *sp)
{

/*
 *    We make several tables here to convert between various external
 *    representations (float, 16-bit, and 8-bit) and the internal
 *    11-bit companded representation.  The 11-bit representation has two
 *    distinct regions.  A linear bottom end up through .018316 in steps
 *    of about .000073, and a region of constant ratio up to about 25.
 *    These floating point numbers are stored in the main table ToLinearF. 
 *    All other tables are derived from this one.  The tables (and the
 *    ratios) are continuous at the internal seam.
 */

    int  nlin, lt2size;
    int  i, j;
    double  b, c, linstep, v;
    float *ToLinearF;
    uint16 *ToLinear16;
    unsigned char *ToLinear8;
    uint16  *FromLT2;
    uint16  *From14; /* Really for 16-bit data, but we shift down 2 */
    uint16  *From8;

    c = log(RATIO);	
    nlin = (int)(1./c);	/* nlin must be an integer */
    c = 1./nlin;
    b = exp(-c*ONE);	/* multiplicative scale factor [b*exp(c*ONE) = 1] */
    linstep = b*c*exp(1.);

    LogK1 = (float)(1./c);	/* if (v >= 2)  token = k1*log(v*k2) */
    LogK2 = (float)(1./b);
    lt2size = (int)(2./linstep) + 1;
    FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16));
    From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16));
    From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16));
    ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float));
    ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16));
    ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char));
    if (FromLT2 == NULL || From14  == NULL || From8   == NULL ||
	 ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) {
	if (FromLT2) _TIFFfree(FromLT2);
	if (From14) _TIFFfree(From14);
	if (From8) _TIFFfree(From8);
	if (ToLinearF) _TIFFfree(ToLinearF);
	if (ToLinear16) _TIFFfree(ToLinear16);
	if (ToLinear8) _TIFFfree(ToLinear8);
	sp->FromLT2 = NULL;
	sp->From14 = NULL;
	sp->From8 = NULL;
	sp->ToLinearF = NULL;
	sp->ToLinear16 = NULL;
	sp->ToLinear8 = NULL;
	return 0;
    }

    j = 0;

    for (i = 0; i < nlin; i++)  {
	v = i * linstep;
	ToLinearF[j++] = (float)v;
    }

    for (i = nlin; i < TSIZE; i++)
	ToLinearF[j++] = (float)(b*exp(c*i));

    ToLinearF[2048] = ToLinearF[2047];

    for (i = 0; i < TSIZEP1; i++)  {
	v = ToLinearF[i]*65535.0 + 0.5;
	ToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v;
	v = ToLinearF[i]*255.0  + 0.5;
	ToLinear8[i]  = (v > 255.0) ? 255 : (unsigned char)v;
    }

    j = 0;
    for (i = 0; i < lt2size; i++)  {
	if ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1])
	    j++;
	FromLT2[i] = (uint16)j;
    }

    /*
     * Since we lose info anyway on 16-bit data, we set up a 14-bit
     * table and shift 16-bit values down two bits on input.
     * saves a little table space.
     */
    j = 0;
    for (i = 0; i < 16384; i++)  {
	while ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1])
	    j++;
	From14[i] = (uint16)j;
    }

    j = 0;
    for (i = 0; i < 256; i++)  {
	while ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1])
	    j++;
	From8[i] = (uint16)j;
    }

    Fltsize = (float)(lt2size/2);

    sp->ToLinearF = ToLinearF;
    sp->ToLinear16 = ToLinear16;
    sp->ToLinear8 = ToLinear8;
    sp->FromLT2 = FromLT2;
    sp->From14 = From14;
    sp->From8 = From8;

    return 1;
}

#define DecoderState(tif)	((PixarLogState*) (tif)->tif_data)
#define EncoderState(tif)	((PixarLogState*) (tif)->tif_data)

static int PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s);
static int PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s);

#define PIXARLOGDATAFMT_UNKNOWN	-1

static int
PixarLogGuessDataFmt(TIFFDirectory *td)
{
	int guess = PIXARLOGDATAFMT_UNKNOWN;
	int format = td->td_sampleformat;

	/* If the user didn't tell us his datafmt,
	 * take our best guess from the bitspersample.
	 */
	switch (td->td_bitspersample) {
	 case 32:
		if (format == SAMPLEFORMAT_IEEEFP)
			guess = PIXARLOGDATAFMT_FLOAT;
		break;
	 case 16:
		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
			guess = PIXARLOGDATAFMT_16BIT;
		break;
	 case 12:
		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_INT)
			guess = PIXARLOGDATAFMT_12BITPICIO;
		break;
	 case 11:
		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
			guess = PIXARLOGDATAFMT_11BITLOG;
		break;
	 case 8:
		if (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)
			guess = PIXARLOGDATAFMT_8BIT;
		break;
	}

	return guess;
}

static tmsize_t
multiply_ms(tmsize_t m1, tmsize_t m2)
{
	tmsize_t bytes = m1 * m2;

	if (m1 && bytes / m1 != m2)
		bytes = 0;

	return bytes;
}

static tmsize_t
add_ms(tmsize_t m1, tmsize_t m2)
{
	tmsize_t bytes = m1 + m2;

	/* if either input is zero, assume overflow already occurred */
	if (m1 == 0 || m2 == 0)
		bytes = 0;
	else if (bytes <= m1 || bytes <= m2)
		bytes = 0;

	return bytes;
}

static int
PixarLogFixupTags(TIFF* tif)
{
	(void) tif;
	return (1);
}

static int
PixarLogSetupDecode(TIFF* tif)
{
	static const char module[] = "PixarLogSetupDecode";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t tbuf_size;

	assert(sp != NULL);

	/* Make sure no byte swapping happens on the data
	 * after decompression. */
	tif->tif_postdecode = _TIFFNoPostDecode;  

	/* for some reason, we can't do this in TIFFInitPixarLog */

	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
	    td->td_samplesperpixel : 1);
	tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),
				      td->td_rowsperstrip), sizeof(uint16));
	/* add one more stride in case input ends mid-stride */
	tbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);
	if (tbuf_size == 0)
		return (0);   /* TODO: this is an error return without error report through TIFFErrorExt */
	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
	if (sp->tbuf == NULL)
		return (0);
sp->tbuf_size = tbuf_size;

	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
		sp->user_datafmt = PixarLogGuessDataFmt(td);
	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
		TIFFErrorExt(tif->tif_clientdata, module,
			"PixarLog compression can't handle bits depth/data format combination (depth: %d)", 
			td->td_bitspersample);
		return (0);
	}

	if (inflateInit(&sp->stream) != Z_OK) {
		TIFFErrorExt(tif->tif_clientdata, module, "%s", sp->stream.msg ? sp->stream.msg : "(null)");
		return (0);
	} else {
		sp->state |= PLSTATE_INIT;
		return (1);
	}
}

/*
 * Setup state for decoding a strip.
 */
static int
PixarLogPreDecode(TIFF* tif, uint16 s)
{
	static const char module[] = "PixarLogPreDecode";
	PixarLogState* sp = DecoderState(tif);

	(void) s;
	assert(sp != NULL);
	sp->stream.next_in = tif->tif_rawdata;
	assert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_in = (uInt) tif->tif_rawcc;
	if ((tmsize_t)sp->stream.avail_in != tif->tif_rawcc)
	{
		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
		return (0);
	}
	return (inflateReset(&sp->stream) == Z_OK);
}

static int
PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
{
	static const char module[] = "PixarLogDecode";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = DecoderState(tif);
	tmsize_t i;
	tmsize_t nsamples;
	int llen;
	uint16 *up;
	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		nsamples = occ / sizeof(float);	/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		nsamples = occ;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			"%d bit input not supported in PixarLog",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));
	if (sp->stream.avail_out != nsamples * sizeof(uint16))
	{
		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
		return (0);
	}
if(__cpr_choice("L65", "bool", (long long[]){sp->tbuf_size,sp->stream.avail_out, nsamples}, (char*[]){"x", "y", "z"}, 3, (int*[]){}, (char*[]){}, 0)) return 0;

if (sp->stream.avail_out > sp->tbuf_size) abort();
	do {
		int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);
		if (state == Z_STREAM_END) {
			break;			/* XXX */
		}
		if (state == Z_DATA_ERROR) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "Decoding error at scanline %lu, %s",
			    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : "(null)");
			if (inflateSync(&sp->stream) != Z_OK)
				return (0);
			continue;
		}
		if (state != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",
			    sp->stream.msg ? sp->stream.msg : "(null)");
			return (0);
		}
	} while (sp->stream.avail_out > 0);

	/* hopefully, we got all the bytes we needed */
	if (sp->stream.avail_out != 0) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Not enough data at scanline %lu (short " TIFF_UINT64_FORMAT " bytes)",
		    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);
		return (0);
	}

	up = sp->tbuf;
	/* Swap bytes in the data if from a different endian machine. */
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabArrayOfShort(up, nsamples);

	/*
	 * if llen is not an exact multiple of nsamples, the decode operation
	 * may overflow the output buffer, so truncate it enough to prevent
	 * that but still salvage as much data as possible.
	 */
	if (nsamples % llen) { 
		TIFFWarningExt(tif->tif_clientdata, module,
			"stride %lu is not a multiple of sample count, "
			"%lu, data truncated.", (unsigned long) llen, (unsigned long) nsamples);
		nsamples -= nsamples % llen;
	}

	for (i = 0; i < nsamples; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalAccumulateF(up, llen, sp->stride,
					(float *)op, sp->ToLinearF);
			op += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalAccumulate16(up, llen, sp->stride,
					(uint16 *)op, sp->ToLinear16);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_12BITPICIO:
			horizontalAccumulate12(up, llen, sp->stride,
					(int16 *)op, sp->ToLinearF);
			op += llen * sizeof(int16);
			break;
		case PIXARLOGDATAFMT_11BITLOG:
			horizontalAccumulate11(up, llen, sp->stride,
					(uint16 *)op);
			op += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalAccumulate8(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		case PIXARLOGDATAFMT_8BITABGR:
			horizontalAccumulate8abgr(up, llen, sp->stride,
					(unsigned char *)op, sp->ToLinear8);
			op += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				  "Unsupported bits/sample: %d",
				  td->td_bitspersample);
			return (0);
		}
	}

	return (1);
}

static int
PixarLogSetupEncode(TIFF* tif)
{
	static const char module[] = "PixarLogSetupEncode";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState* sp = EncoderState(tif);
	tmsize_t tbuf_size;

	assert(sp != NULL);

	/* for some reason, we can't do this in TIFFInitPixarLog */

	sp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
	    td->td_samplesperpixel : 1);
	tbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),
				      td->td_rowsperstrip), sizeof(uint16));
	if (tbuf_size == 0)
		return (0);  /* TODO: this is an error return without error report through TIFFErrorExt */
	sp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);
	if (sp->tbuf == NULL)
		return (0);
	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)
		sp->user_datafmt = PixarLogGuessDataFmt(td);
	if (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {
		TIFFErrorExt(tif->tif_clientdata, module, "PixarLog compression can't handle %d bit linear encodings", td->td_bitspersample);
		return (0);
	}

	if (deflateInit(&sp->stream, sp->quality) != Z_OK) {
		TIFFErrorExt(tif->tif_clientdata, module, "%s", sp->stream.msg ? sp->stream.msg : "(null)");
		return (0);
	} else {
		sp->state |= PLSTATE_INIT;
		return (1);
	}
}

/*
 * Reset encoding state at the start of a strip.
 */
static int
PixarLogPreEncode(TIFF* tif, uint16 s)
{
	static const char module[] = "PixarLogPreEncode";
	PixarLogState *sp = EncoderState(tif);

	(void) s;
	assert(sp != NULL);
	sp->stream.next_out = tif->tif_rawdata;
	assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_out = (uInt)tif->tif_rawdatasize;
	if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize)
	{
		TIFFErrorExt(tif->tif_clientdata, module, "ZLib cannot deal with buffers this size");
		return (0);
	}
	return (deflateReset(&sp->stream) == Z_OK);
}

static void
horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)
{
    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;
    float fltsize = Fltsize;

#define  CLAMP(v) ( (v<(float)0.)   ? 0				\
		  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]	\
		  : (v>(float)24.2) ? 2047			\
		  : LogK1*log(v*LogK2) + 0.5 )

    mask = CODE_MASK;
    if (n >= stride) {
	if (stride == 3) {
	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
	    n -= 3;
	    while (n > 0) {
		n -= 3;
		wp += 3;
		ip += 3;
		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
	    }
	} else if (stride == 4) {
	    r2 = wp[0] = (uint16) CLAMP(ip[0]);
	    g2 = wp[1] = (uint16) CLAMP(ip[1]);
	    b2 = wp[2] = (uint16) CLAMP(ip[2]);
	    a2 = wp[3] = (uint16) CLAMP(ip[3]);
	    n -= 4;
	    while (n > 0) {
		n -= 4;
		wp += 4;
		ip += 4;
		r1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
		a1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;
	    }
	} else {
	    ip += n - 1;	/* point to last one */
	    wp += n - 1;	/* point to last one */
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);
				wp[stride] -= wp[0];
				wp[stride] &= mask;
				wp--; ip--)
		n -= stride;
	    }
	    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)
	}
    }
}

static void
horizontalDifference16(unsigned short *ip, int n, int stride, 
	unsigned short *wp, uint16 *From14)
{
    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;

/* assumption is unsigned pixel values */
#undef   CLAMP
#define  CLAMP(v) From14[(v) >> 2]

    mask = CODE_MASK;
    if (n >= stride) {
	if (stride == 3) {
	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
	    b2 = wp[2] = CLAMP(ip[2]);
	    n -= 3;
	    while (n > 0) {
		n -= 3;
		wp += 3;
		ip += 3;
		r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
	    }
	} else if (stride == 4) {
	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
	    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);
	    n -= 4;
	    while (n > 0) {
		n -= 4;
		wp += 4;
		ip += 4;
		r1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;
		a1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;
	    }
	} else {
	    ip += n - 1;	/* point to last one */
	    wp += n - 1;	/* point to last one */
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride, wp[0] = CLAMP(ip[0]);
				wp[stride] -= wp[0];
				wp[stride] &= mask;
				wp--; ip--)
		n -= stride;
	    }
	    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)
	}
    }
}


static void
horizontalDifference8(unsigned char *ip, int n, int stride, 
	unsigned short *wp, uint16 *From8)
{
    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;

#undef	 CLAMP
#define  CLAMP(v) (From8[(v)])

    mask = CODE_MASK;
    if (n >= stride) {
	if (stride == 3) {
	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
	    b2 = wp[2] = CLAMP(ip[2]);
	    n -= 3;
	    while (n > 0) {
		n -= 3;
		r1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;
		wp += 3;
		ip += 3;
	    }
	} else if (stride == 4) {
	    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);
	    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);
	    n -= 4;
	    while (n > 0) {
		n -= 4;
		r1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;
		g1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;
		b1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;
		a1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;
		wp += 4;
		ip += 4;
	    }
	} else {
	    wp += n + stride - 1;	/* point to last one */
	    ip += n + stride - 1;	/* point to last one */
	    n -= stride;
	    while (n > 0) {
		REPEAT(stride, wp[0] = CLAMP(ip[0]);
				wp[stride] -= wp[0];
				wp[stride] &= mask;
				wp--; ip--)
		n -= stride;
	    }
	    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)
	}
    }
}

/*
 * Encode a chunk of pixels.
 */
static int
PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
{
	static const char module[] = "PixarLogEncode";
	TIFFDirectory *td = &tif->tif_dir;
	PixarLogState *sp = EncoderState(tif);
	tmsize_t i;
	tmsize_t n;
	int llen;
	unsigned short * up;

	(void) s;

	switch (sp->user_datafmt) {
	case PIXARLOGDATAFMT_FLOAT:
		n = cc / sizeof(float);		/* XXX float == 32 bits */
		break;
	case PIXARLOGDATAFMT_16BIT:
	case PIXARLOGDATAFMT_12BITPICIO:
	case PIXARLOGDATAFMT_11BITLOG:
		n = cc / sizeof(uint16);	/* XXX uint16 == 16 bits */
		break;
	case PIXARLOGDATAFMT_8BIT:
	case PIXARLOGDATAFMT_8BITABGR:
		n = cc;
		break;
	default:
		TIFFErrorExt(tif->tif_clientdata, module,
			"%d bit input not supported in PixarLog",
			td->td_bitspersample);
		return 0;
	}

	llen = sp->stride * td->td_imagewidth;

	for (i = 0, up = sp->tbuf; i < n; i += llen, up += llen) {
		switch (sp->user_datafmt)  {
		case PIXARLOGDATAFMT_FLOAT:
			horizontalDifferenceF((float *)bp, llen, 
				sp->stride, up, sp->FromLT2);
			bp += llen * sizeof(float);
			break;
		case PIXARLOGDATAFMT_16BIT:
			horizontalDifference16((uint16 *)bp, llen, 
				sp->stride, up, sp->From14);
			bp += llen * sizeof(uint16);
			break;
		case PIXARLOGDATAFMT_8BIT:
			horizontalDifference8((unsigned char *)bp, llen, 
				sp->stride, up, sp->From8);
			bp += llen * sizeof(unsigned char);
			break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module,
				"%d bit input not supported in PixarLog",
				td->td_bitspersample);
			return 0;
		}
	}
 
	sp->stream.next_in = (unsigned char *) sp->tbuf;
	assert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,
	    we need to simplify this code to reflect a ZLib that is likely updated
	    to deal with 8byte memory sizes, though this code will respond
	    appropriately even before we simplify it */
	sp->stream.avail_in = (uInt) (n * sizeof(uint16));
	if ((sp->stream.avail_in / sizeof(uint16)) != (uInt) n)
	{
		TIFFErrorExt(tif->tif_clientdata, module,
			     "ZLib cannot deal with buffers this size");
		return (0);
	}

	do {
		if (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {
			TIFFErrorExt(tif->tif_clientdata, module, "Encoder error: %s",
			    sp->stream.msg ? sp->stream.msg : "(null)");
			return (0);
		}
		if (sp->stream.avail_out == 0) {
			tif->tif_rawcc = tif->tif_rawdatasize;
			TIFFFlushData1(tif);
			sp->stream.next_out = tif->tif_rawdata;
			sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */
		}
	} while (sp->stream.avail_in > 0);
	return (1);
}

/*
 * Finish off an encoded strip by flushing the last
 * string and tacking on an End Of Information code.
 */

static int
PixarLogPostEncode(TIFF* tif)
{
	static const char module[] = "PixarLogPostEncode";
	PixarLogState *sp = EncoderState(tif);
	int state;

	sp->stream.avail_in = 0;

	do {
		state = deflate(&sp->stream, Z_FINISH);
		switch (state) {
		case Z_STREAM_END:
		case Z_OK:
		    if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {
			    tif->tif_rawcc =
				tif->tif_rawdatasize - sp->stream.avail_out;
			    TIFFFlushData1(tif);
			    sp->stream.next_out = tif->tif_rawdata;
			    sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */
		    }
		    break;
		default:
			TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",
			sp->stream.msg ? sp->stream.msg : "(null)");
		    return (0);
		}
	} while (state != Z_STREAM_END);
	return (1);
}

static void
PixarLogClose(TIFF* tif)
{
	TIFFDirectory *td = &tif->tif_dir;

	/* In a really sneaky (and really incorrect, and untruthful, and
	 * troublesome, and error-prone) maneuver that completely goes against
	 * the spirit of TIFF, and breaks TIFF, on close, we covertly
	 * modify both bitspersample and sampleformat in the directory to
	 * indicate 8-bit linear.  This way, the decode "just works" even for
	 * readers that don't know about PixarLog, or how to set
	 * the PIXARLOGDATFMT pseudo-tag.
	 */
	td->td_bitspersample = 8;
	td->td_sampleformat = SAMPLEFORMAT_UINT;
}

static void
PixarLogCleanup(TIFF* tif)
{
	PixarLogState* sp = (PixarLogState*) tif->tif_data;

	assert(sp != 0);

	(void)TIFFPredictorCleanup(tif);

	tif->tif_tagmethods.vgetfield = sp->vgetparent;
	tif->tif_tagmethods.vsetfield = sp->vsetparent;

	if (sp->FromLT2) _TIFFfree(sp->FromLT2);
	if (sp->From14) _TIFFfree(sp->From14);
	if (sp->From8) _TIFFfree(sp->From8);
	if (sp->ToLinearF) _TIFFfree(sp->ToLinearF);
	if (sp->ToLinear16) _TIFFfree(sp->ToLinear16);
	if (sp->ToLinear8) _TIFFfree(sp->ToLinear8);
	if (sp->state&PLSTATE_INIT) {
		if (tif->tif_mode == O_RDONLY)
			inflateEnd(&sp->stream);
		else
			deflateEnd(&sp->stream);
	}
	if (sp->tbuf)
		_TIFFfree(sp->tbuf);
	_TIFFfree(sp);
	tif->tif_data = NULL;

	_TIFFSetDefaultCompressionState(tif);
}

static int
PixarLogVSetField(TIFF* tif, uint32 tag, va_list ap)
{
    static const char module[] = "PixarLogVSetField";
    PixarLogState *sp = (PixarLogState *)tif->tif_data;
    int result;

    switch (tag) {
     case TIFFTAG_PIXARLOGQUALITY:
		sp->quality = (int) va_arg(ap, int);
		if (tif->tif_mode != O_RDONLY && (sp->state&PLSTATE_INIT)) {
			if (deflateParams(&sp->stream,
			    sp->quality, Z_DEFAULT_STRATEGY) != Z_OK) {
				TIFFErrorExt(tif->tif_clientdata, module, "ZLib error: %s",
					sp->stream.msg ? sp->stream.msg : "(null)");
				return (0);
			}
		}
		return (1);
     case TIFFTAG_PIXARLOGDATAFMT:
	sp->user_datafmt = (int) va_arg(ap, int);
	/* Tweak the TIFF header so that the rest of libtiff knows what
	 * size of data will be passed between app and library, and
	 * assume that the app knows what it is doing and is not
	 * confused by these header manipulations...
	 */
	switch (sp->user_datafmt) {
	 case PIXARLOGDATAFMT_8BIT:
	 case PIXARLOGDATAFMT_8BITABGR:
	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
	    break;
	 case PIXARLOGDATAFMT_11BITLOG:
	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
	    break;
	 case PIXARLOGDATAFMT_12BITPICIO:
	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);
	    break;
	 case PIXARLOGDATAFMT_16BIT:
	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);
	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);
	    break;
	 case PIXARLOGDATAFMT_FLOAT:
	    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);
	    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);
	    break;
	}
	/*
	 * Must recalculate sizes should bits/sample change.
	 */
	tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);
	tif->tif_scanlinesize = TIFFScanlineSize(tif);
	result = 1;		/* NB: pseudo tag */
	break;
     default:
	result = (*sp->vsetparent)(tif, tag, ap);
    }
    return (result);
}

static int
PixarLogVGetField(TIFF* tif, uint32 tag, va_list ap)
{
    PixarLogState *sp = (PixarLogState *)tif->tif_data;

    switch (tag) {
     case TIFFTAG_PIXARLOGQUALITY:
	*va_arg(ap, int*) = sp->quality;
	break;
     case TIFFTAG_PIXARLOGDATAFMT:
	*va_arg(ap, int*) = sp->user_datafmt;
	break;
     default:
	return (*sp->vgetparent)(tif, tag, ap);
    }
    return (1);
}

static const TIFFField pixarlogFields[] = {
    {TIFFTAG_PIXARLOGDATAFMT, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT, TIFF_SETGET_UNDEFINED, FIELD_PSEUDO, FALSE, FALSE, "", NULL},
    {TIFFTAG_PIXARLOGQUALITY, 0, 0, TIFF_ANY, 0, TIFF_SETGET_INT, TIFF_SETGET_UNDEFINED, FIELD_PSEUDO, FALSE, FALSE, "", NULL}
};

int
TIFFInitPixarLog(TIFF* tif, int scheme)
{
	static const char module[] = "TIFFInitPixarLog";

	PixarLogState* sp;

	assert(scheme == COMPRESSION_PIXARLOG);

	/*
	 * Merge codec-specific tag information.
	 */
	if (!_TIFFMergeFields(tif, pixarlogFields,
			      TIFFArrayCount(pixarlogFields))) {
		TIFFErrorExt(tif->tif_clientdata, module,
			     "Merging PixarLog codec-specific tags failed");
		return 0;
	}

	/*
	 * Allocate state block so tag methods have storage to record values.
	 */
	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (PixarLogState));
	if (tif->tif_data == NULL)
		goto bad;
	sp = (PixarLogState*) tif->tif_data;
	_TIFFmemset(sp, 0, sizeof (*sp));
	sp->stream.data_type = Z_BINARY;
	sp->user_datafmt = PIXARLOGDATAFMT_UNKNOWN;

	/*
	 * Install codec methods.
	 */
	tif->tif_fixuptags = PixarLogFixupTags; 
	tif->tif_setupdecode = PixarLogSetupDecode;
	tif->tif_predecode = PixarLogPreDecode;
	tif->tif_decoderow = PixarLogDecode;
	tif->tif_decodestrip = PixarLogDecode;  
	tif->tif_decodetile = PixarLogDecode;
	tif->tif_setupencode = PixarLogSetupEncode;
	tif->tif_preencode = PixarLogPreEncode;
	tif->tif_postencode = PixarLogPostEncode;
	tif->tif_encoderow = PixarLogEncode;  
	tif->tif_encodestrip = PixarLogEncode;
	tif->tif_encodetile = PixarLogEncode;  
	tif->tif_close = PixarLogClose;
	tif->tif_cleanup = PixarLogCleanup;

	/* Override SetField so we can handle our private pseudo-tag */
	sp->vgetparent = tif->tif_tagmethods.vgetfield;
	tif->tif_tagmethods.vgetfield = PixarLogVGetField;   /* hook for codec tags */
	sp->vsetparent = tif->tif_tagmethods.vsetfield;
	tif->tif_tagmethods.vsetfield = PixarLogVSetField;   /* hook for codec tags */

	/* Default values for codec-specific fields */
	sp->quality = Z_DEFAULT_COMPRESSION; /* default comp. level */
	sp->state = 0;

	/* we don't wish to use the predictor, 
	 * the default is none, which predictor value 1
	 */
	(void) TIFFPredictorInit(tif);

	/*
	 * build the companding tables 
	 */
	PixarLogMakeTables(sp);

	return (1);
bad:
	TIFFErrorExt(tif->tif_clientdata, module,
		     "No space for PixarLog state block");
	return (0);
}
#endif /* PIXARLOG_SUPPORT */

/* vim: set ts=8 sts=8 sw=8 noet: */
/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 8
 * fill-column: 78
 * End:
 */
